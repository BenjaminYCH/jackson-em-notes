package main

import (
	"flag"
	"fmt"
	"math/big"
	"os"
	"path/filepath"
	"sync"
)

/*
Program to calculate Jackson prob 1.23 with arbitrary resolution finite elements.
Example plots:
octave --persist /var/folders/_0/2d8v_l8x5r947l5f35hdx0yw0000gq/T/jackson_prob_1_23.m
*/
var (
	prec       = flag.Uint("prec", 1000, "precision")
	errorBound = flag.Float64("error-bound", 1e-5, "error bound")
	spacings   = flag.Int("spacings", 0, "spacings")
)

func main() {
	flag.Parse()
	n := *spacings
	if n%2 == 1 {
		panic("need even --spacings")
	}
	buf := make([]*big.Float, (2*n+1)*(n+1))

	// Initialize inner y=0 line to high potential value.
	for x := 0; x <= n; x++ {
		buf[x] = big.NewFloat(1).SetPrec(*prec)
	}
	// Initialize y=n line to zero potential value.
	for x := 0; x <= 2*n; x++ {
		buf[n*(2*n+1)+x] = big.NewFloat(0).SetPrec(*prec)
	}
	// Initialize interior potential with interpolated y.
	for y := 1; y < n; y++ {
		v := big.NewFloat(float64(n-y) / float64(n)).SetPrec(*prec)
		for x := 0; x <= n+y; x++ {
			buf[y*(2*n+1)+x] = v
		}
	}
	errBound := big.NewFloat(*errorBound).SetPrec(*prec)
	var e *big.Float
	for i := 0; true; i++ {
		buf, e = oneIteration(buf, n)
		if i%100 == 0 {
			fmt.Printf("iteration %v, max-error: %v\n", i, e)
		}
		if e.Cmp(errBound) < 0 {
			break
		}
	}

	phi1, _ := get(buf, n, 0, n/2).Float64()
	phi2, _ := get(buf, n, n/2, n/2).Float64()
	phi3, _ := get(buf, n, n, n/2).Float64()
	phi4, _ := get(buf, n, n*3/2, n/2).Float64()
	fmt.Printf("Φ1=%v, Φ2=%v, Φ3=%v, Φ4=%v\n", phi1*100, phi2*100, phi3*100, phi4*100)

	mesh := make([]float64, (4*n+1)*(4*n+1))
	tx := make([]float64, 4*n+1)
	ty := make([]float64, 4*n+1)
	step := 1 / float64(n)
	abs := func(x int) int {
		if x >= 0 {
			return x
		}
		return -x
	}
	f64 := func(x, y int) float64 {
		f, _ := get(buf, n, x, y).Float64()
		return f * 100
	}

	for x := -(2 * n); x <= 2*n; x++ {
		tx[x+2*n] = float64(x) * step
		ty[x+2*n] = float64(x) * step
		absx := abs(x)
		for y := -(2 * n); y <= 2*n; y++ {
			absy := abs(y)
			idx := (y+2*n)*(4*n+1) + x + 2*n
			if absx <= n && absy <= n {
				mesh[idx] = 100
			}
			if absx <= n && absy > n {
				mesh[idx] = f64(absx, absy-n)
			}
			if absx > n && absy <= n {
				mesh[idx] = f64(absy, absx-n)
			}
			if absx > n && absy > n {
				dx, dy := absx-n, absy-n
				if dx <= dy {
					mesh[idx] = f64(n+dx, dy)
				} else {
					mesh[idx] = f64(n+dy, dx)
				}
			}
		}
	}

	// Write an octave script for visualization of the potential.
	filename := filepath.Join(os.TempDir(), "jackson_prob_1_23.m")
	file, err := os.Create(filename)
	if err != nil {
		panic(err)
	}
	defer file.Close()

	fmt.Fprintf(file, "tx=%v;\n", tx)
	fmt.Fprintf(file, "ty=%v;\n", ty)
	fmt.Fprintf(file, "phi=[\n")
	for y := 0; y <= 4*n; y++ {
		for x := 0; x <= 4*n; x++ {
			fmt.Fprintf(file, "%v ", mesh[y*(4*n+1)+x])
		}
		fmt.Fprintf(file, "\n")
	}
	fmt.Fprintf(file, "];\n")
	fmt.Fprintf(file, "mesh(tx, ty, phi);\n")
	fmt.Println(filename)
}

// "Improvied" averaging scheme, mixing cross and square scheme with 4:1 weighting.
func improvedAvg(n, ne, e, se, s, sw, w, nw *big.Float) *big.Float {
	sc := big.NewFloat(0).SetPrec(*prec)
	sc = sc.Add(n, e)
	sc = sc.Add(sc, s)
	sc = sc.Add(sc, w)
	ss := big.NewFloat(0).SetPrec(*prec)
	ss = ss.Add(ne, se)
	ss = ss.Add(ss, sw)
	ss = ss.Add(ss, nw)

	f1 := big.NewFloat(0.2).SetPrec(*prec)
	f1 = f1.Mul(f1, sc)
	f2 := big.NewFloat(0.05).SetPrec(*prec)
	f2 = f2.Mul(f2, ss)
	f1 = f1.Add(f1, f2)
	return f1
}

// Calculates the potential value for the grid for one iteration.
func oneIteration(buf []*big.Float, n int) ([]*big.Float, *big.Float) {
	ret := make([]*big.Float, len(buf))
	copy(ret, buf)

	const maxWorkers = 20
	var wg sync.WaitGroup
	workers := maxWorkers
	if n-1 < maxWorkers {
		workers = n - 1
	}
	wg.Add(workers)
	maxErr := make([]*big.Float, workers)
	for w := 0; w < workers; w++ {
		go func(worker int) {
			maxErr[worker] = big.NewFloat(-1.0).SetPrec(*prec)
			defer wg.Done()
			for y := 1; y < n; y++ {
				if y%workers != worker {
					continue
				}
				for x := 0; x <= n+y; x++ {
					newVal := improvedAvg(
						get(buf, n, x, y-1),
						get(buf, n, x+1, y-1),
						get(buf, n, x+1, y),
						get(buf, n, x+1, y+1),
						get(buf, n, x, y+1),
						get(buf, n, x-1, y+1),
						get(buf, n, x-1, y),
						get(buf, n, x-1, y-1),
					)
					ret[y*(2*n+1)+x] = newVal
					e := big.NewFloat(0).SetPrec(*prec).Sub(newVal, get(buf, n, x, y))
					e = e.Abs(e)
					if maxErr[worker].Sign() < 0 || maxErr[worker].Cmp(e) < 0 {
						maxErr[worker].Set(e)
					}
				}
			}
		}(w)
	}
	wg.Wait()
	maxE := maxErr[0]
	for w := 1; w < workers; w++ {
		if maxE.Cmp(maxErr[w]) < 0 {
			maxE.Set(maxErr[w])
		}
	}
	return ret, maxE
}

// Reads the grid potential values.
func get(buf []*big.Float, n, x, y int) *big.Float {
	if y < 0 || y > n {
		panic("out of bound y")
	}
	if x > 2*n {
		panic("out of bound x")
	}
	if x-n > y+2 {
		panic(fmt.Sprintf("too far from diagonal: (%v, %v)\n", x, y))
	}

	if x < 0 {
		x = -x
	}
	if x-n > y {
		// Flip across diagonal.
		x, y = n+y, x-n
	}
	return buf[y*(2*n+1)+x]
}
